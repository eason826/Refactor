	熟悉VC/MFC的都知道，VC是“基于消息，事件驱动”，消息在VC开发中起着举足轻重的作
用。在MFC中，消息是通过一个向上递交的方式进行处理，例如一个WM_COMMAND消息的处理流程
可能为：
	1） MDI主窗口（CMDIFrameWnd）收到命令消息WM_COMMAND，其ID位ID_×××；
	2） MDI主窗口将消息传给当前活动的MDI子窗口（CMDIChildWnd）；
	3） MDI子窗口给自己的子窗口（View）一个处理机会，将消息交给View；
	4） View检查自己Message Map；
	5） 如果View没有发现处理该消息的程序，则将该消息传给其对应的Document对象；否则
View处理，消息流程结束。
	6） Document检查自己Message Map，如果没有该消息的处理程序，则将该消息传给其对象
的DocumentTemplate处理；否则自己处理，消息流程结束；
	7） 如果在6）中消息没有得到处理，则将消息返回给View；
	8） View再传回给MDI子窗口；
	9） MDI子窗口将该消息传给CwinApp对象，CwinApp为所有无主的消息提供了处理。
	注明：有关MFC消息处理更加详细信息，请参考候捷先生的《深入浅出MFC》。
	MFC提供了消息的处理的链式处理策略，处理消息的请求将沿着预先定义好的路径依次进行
处理。消息的发送者并不知道该消息最后是由那个具体对象处理的，当然它也无须也不想知道，
但是结构是该消息被某个对象处理了，或者一直到一个终极的对象进行处理了。
	Chain of Responsibility模式描述其实就是这样一类问题将可能处理一个请求的对象链接
成一个链，并将请求在这个链上传递，直到有对象处理该请求（可能需要提供一个默认处理所
有请求的类，例如MFC中的CwinApp类）。

	Chain of Responsibility模式的最大的一个有点就是给系统降低了耦合性，请求的发送者
完全不必知道该请求会被哪个应答对象处理，极大地降低了系统的耦合性。