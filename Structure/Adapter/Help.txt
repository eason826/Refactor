    Adapter模式解决的问题在生活中经常会遇到：比如我们有一个Team为外界提供S类服务，
但是我们Team里面没有能够完成此项人物的member，然后我们得知有A可以完成这项服务（他
把这项人物重新取了个名字叫S’，并且他不对外公布他的具体实现）。为了保证我们对外的
服务类别的一致性（提供S服务），我们有以下两种方式解决这个问题：
    1）把B君直接招安到我们Team为我们工作，提供S服务的时候让B君去办就是了；
    2）B君可能在别的地方有工作，并且不准备接受我们的招安，于是我们Team可以想这样一
种方式解决问题：我们安排C君去完成这项任务，并做好工作（Money：））让A君工作的时候可
以向B君请教，因此C君就是一个复合体（提供S服务，但是是B君的继承弟子）。
    实际上在软件系统设计和开发中，这种问题也会经常遇到：我们为了完成某项工作购买了
一个第三方的库来加快开发。这就带来了一个问题：我们在应用程序中已经设计好了接口，与
这个第三方提供的接口不一致，为了使得这些接口不兼容的类（不能在一起工作）可以在一起
工作了，Adapter模式提供了将一个类（第三方库）的接口转化为客户（购买使用者）希望的
接口。
    在上面生活中问题的解决方式也就正好对应了Adapter模式的两种类别：类模式和对象模式。

	在Adapter模式的两种模式中，有一个很重要的概念就是接口继承和实现继承的区别和联系
。接口继承和实现继承是面向对象领域的两个重要的概念，接口继承指的是通过继承，子类获
得了父类的接口，而实现继承指的是通过继承子类获得了父类的实现（并不统共接口）。在C++
中的public继承既是接口继承又是实现继承，因为子类在继承了父类后既可以对外提供父类中
的接口操作，又可以获得父类的接口实现。当然我们可以通过一定的方式和技术模拟单独的接
口继承和实现继承，例如我们可以通过private继承获得实现继承的效果（private继承后，父
类中的接口都变为private，当然只能是实现继承了。），通过纯抽象基类模拟接口继承的效果
，但是在C++中pure virtual function也可以提供默认实现，因此这是不纯正的接口继承，但
是在Java中我们可以interface来获得真正的接口继承了。